Got it — here’s a clean, surgical Step 38 to persist Truth Lab results, expose a GET endpoint, and hook the client — the right way.

Step 38 — Persist Truth Lab (DB schema + store + GET API + client fetch)

Human steps (you do these first)
	1.	Confirm these Replit Secrets exist (they are required for DB writes):
	•	DATABASE_URL
	•	SUPABASE_SERVICE_KEY (we won’t use it directly here, but confirm it’s present)
	•	SESSION_SECRET
	2.	No UI edits needed in this step. You don’t need to touch vite.config.ts or any Replit-only files.

When done, tell the agent to run the block below.

⸻

Replit Agent — execute exactly in order

38.1 Create idempotent DB migration for Truth Lab

File: server/db/migrations/2025-08-27-truth-lab.sql

-- Enable uuid if needed
create extension if not exists "pgcrypto";

-- TRUTH CHECKS
create table if not exists public.truth_checks (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null,
  project_id uuid,
  title text,
  input_text text,
  input_urls text[],
  input_images text[],
  result jsonb not null,
  confidence numeric,
  status text not null default 'complete',
  created_at timestamptz not null default now()
);

-- TRUTH EVIDENCE
create table if not exists public.truth_evidence (
  id uuid primary key default gen_random_uuid(),
  truth_check_id uuid not null references public.truth_checks(id) on delete cascade,
  quote text,
  url text,
  source text,
  event_timestamp text, -- keep as text; sources vary (ISO/string)
  created_at timestamptz not null default now()
);

-- Helpful indexes
create index if not exists idx_truth_checks_user on public.truth_checks(user_id);
create index if not exists idx_truth_checks_project on public.truth_checks(project_id);
create index if not exists idx_truth_checks_created on public.truth_checks(created_at desc);
create index if not exists idx_truth_evidence_check on public.truth_evidence(truth_check_id);

File: server/db/runMigrations.ts

import fs from "fs";
import path from "path";
import { Pool } from "pg";

const ssl =
  process.env.NODE_ENV === "production" ? { rejectUnauthorized: false } : false;

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: ssl as any,
});

export async function runTruthLabMigration() {
  const file = path.resolve(
    __dirname,
    "migrations",
    "2025-08-27-truth-lab.sql"
  );
  const sql = fs.readFileSync(file, "utf8");
  await pool.query(sql);
}

Wire at bootstrap (runs once on start).
Edit server/index.ts and add near other bootstraps (top-level, before routes mount):

import { runTruthLabMigration } from "./db/runMigrations";
// ...
await runTruthLabMigration().catch((e) => {
  console.error("[migrations] truth-lab migration failed:", e);
  process.exit(1);
});

If server/index.ts isn’t async, wrap in an IIFE or call inside your existing async bootstrap. If your repo already has a migration runner, call that instead and place the SQL file where it expects.

⸻

38.2 Lightweight PG access + store helpers

File: server/lib/pg.ts

import { Pool } from "pg";
const ssl =
  process.env.NODE_ENV === "production" ? { rejectUnauthorized: false } : false;

export const pg = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: ssl as any,
});

File: server/services/truth/store.ts

import { pg } from "../../lib/pg";

export type EvidenceItem = {
  quote?: string;
  url?: string;
  source?: string;
  timestamp?: string; // keep flexible
};

export type SaveTruthCheckArgs = {
  userId: string;
  projectId?: string | null;
  title?: string;
  inputText?: string;
  inputUrls?: string[];
  inputImages?: string[];
  result: any;        // JSON from the model
  confidence?: number;
  status?: string;    // 'complete' | 'error' | ...
};

export async function saveTruthCheck(args: SaveTruthCheckArgs) {
  const {
    userId,
    projectId = null,
    title,
    inputText,
    inputUrls,
    inputImages,
    result,
    confidence = result?.confidence ?? null,
    status = "complete",
  } = args;

  const q = `
    insert into public.truth_checks
      (user_id, project_id, title, input_text, input_urls, input_images, result, confidence, status)
    values
      ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    returning id
  `;
  const { rows } = await pg.query(q, [
    userId,
    projectId,
    title ?? null,
    inputText ?? null,
    inputUrls ?? null,
    inputImages ?? null,
    result ?? {},
    confidence,
    status,
  ]);
  return rows[0].id as string;
}

export async function saveEvidence(truthCheckId: string, evidence: EvidenceItem[]) {
  if (!evidence?.length) return;
  const q = `
    insert into public.truth_evidence
      (truth_check_id, quote, url, source, event_timestamp)
    values
      ($1, $2, $3, $4, $5)
  `;
  for (const e of evidence) {
    await pg.query(q, [
      truthCheckId,
      e.quote ?? null,
      e.url ?? null,
      e.source ?? null,
      e.timestamp ?? null,
    ]);
  }
}

export async function getTruthCheckById(id: string) {
  const checkQ = `select * from public.truth_checks where id = $1`;
  const evQ = `select * from public.truth_evidence where truth_check_id = $1 order by created_at asc`;
  const [check, ev] = await Promise.all([
    pg.query(checkQ, [id]),
    pg.query(evQ, [id]),
  ]);
  if (!check.rows[0]) return null;
  return { check: check.rows[0], evidence: ev.rows };
}


⸻

38.3 Persist inside the analysis pipeline

Edit: server/services/truth/pipeline.ts
Replace the “TODO: replace with actual DB saves …” section with:

import { saveTruthCheck, saveEvidence } from "./store";
// ...
  const truthCheckId = await saveTruthCheck({
    userId,
    projectId: projectId ?? null,
    title: input.title,
    inputText: input.text,
    inputUrls: input.urls,
    inputImages: input.imageUrls,
    result,
    confidence: result?.confidence,
    status: "complete",
  });

  const ev: any[] = Array.isArray(result?.evidence) ? result.evidence : [];
  if (ev.length) {
    await saveEvidence(truthCheckId, ev.map((e) => ({
      quote: e.quote,
      url: e.url,
      source: e.source,
      timestamp: e.timestamp,
    })));
  }

  return { truthCheckId, result };


⸻

38.4 Expose GET endpoint

Edit: server/routes/truth.ts
Add this route:

import { getTruthCheckById } from "../services/truth/store";
// ...
  app.get("/api/truth/check/:id", requireAuth, async (req, res) => {
    const userId = req.user!.id;
    const id = req.params.id;
    const found = await getTruthCheckById(id);
    if (!found) return res.status(404).json({ error: "not_found" });

    // Optional: scope enforcement (ensure record belongs to user or project)
    if (found.check.user_id !== userId) {
      // TODO: allow collaborators; for now, enforce strict ownership
      return res.status(403).json({ error: "forbidden" });
    }
    return res.json(found);
  });


⸻

38.5 Update client service to fetch results

Edit: client/src/ui-v2/services/truth.ts

export async function getTruthCheck(id: ID) {
  const res = await fetch(`/api/truth/check/${id}`, {
    headers: { "Content-Type": "application/json" },
  });
  if (!res.ok) throw new Error(`getTruthCheck failed: ${res.status}`);
  return res.json() as Promise<{
    check: {
      id: string;
      title: string | null;
      result: any;
      confidence: number | null;
      created_at: string;
    };
    evidence: Array<{
      id: string;
      quote: string | null;
      url: string | null;
      source: string | null;
      event_timestamp: string | null;
    }>;
  }>;
}


⸻

38.6 Smoke test (API with auth)

# Health
curl -sS http://localhost:5001/api/truth/health | jq .

# Get a real user token (paste) and test:
TOKEN="PASTE_USER_ACCESS_TOKEN"

# Create a check
NEW=$(curl -sS -X POST http://localhost:5001/api/truth/analyze-text \
  -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
  -H "X-Project-ID: demo" \
  -d '{"title":"Test", "text":"Creators are moving to long-form explainers to build trust."}')
echo "$NEW" | jq .

ID=$(echo "$NEW" | jq -r '.truthCheckId')

# Fetch it back
curl -sS -H "Authorization: Bearer $TOKEN" \
  http://localhost:5001/api/truth/check/$ID | jq .


⸻

38.7 Commit & tag

git add -A
git commit -m "feat(truth-lab): DB migrations, store helpers, GET /api/truth/check/:id, client fetch"
git tag -f step-38-truth-persist
git push && git push --force --tags


⸻

What this completes
	•	Durable persistence for Truth Lab results (truth_checks) and receipts (truth_evidence).
	•	A clean GET API to retrieve any analysis by id (with basic ownership guard).
	•	Client fetch wired so UI can show full result + receipts.
	•	Idempotent migration so reruns won’t explode.

When this passes the smoke test, we’ll handle Step 39: UI wiring (show loading/progressive reveal, receipts UI, error states) and optional bundle grouping UX for multi-screenshot threads.