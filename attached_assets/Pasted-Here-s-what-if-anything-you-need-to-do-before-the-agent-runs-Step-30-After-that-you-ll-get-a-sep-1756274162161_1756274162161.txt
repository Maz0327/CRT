Here’s what (if anything) you need to do before the agent runs Step 30. After that, you’ll get a separate block for the Replit agent.

⸻

Human steps (quick)

None for this step. Keep the app running on port 3000 and stay logged in.

⸻

Replit Agent — Step 30 (Stabilize the Inbox / Captures list + status updates)

Objective:
Make the “Inbox” (captures) page reliable: list captures for the current project, update their status (new | keep | trash), and ensure the client uses the unified API helper and project header set in Step 28–29.

⸻

30.1 Server — Minimal, predictable Captures API

Create/replace server/routes/captures-basic.ts with a lean, project-scoped set of endpoints. (Do not remove any advanced/legacy routes; mount this alongside them for stability.)

// server/routes/captures-basic.ts
import { Router } from "express";
import { Pool } from "pg";

const router = Router();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === "production" ? { rejectUnauthorized: false } : false,
});

// Assumptions:
// - There is a `captures` table with columns:
//   id (uuid), project_id (uuid), user_id (uuid), title (text), url (text),
//   status (text default 'new'), tags (text[] default '{}'::text[]),
//   created_at (timestamptz default now()), updated_at (timestamptz default now())

// GET /api/captures?status=new|keep|trash
router.get("/captures", async (req, res, next) => {
  try {
    if (!req.user) return res.status(401).json({ error: "unauthorized" });
    // projectId comes from project-scope middleware (Step 28)
    const projectId = (req as any).projectId as string | undefined;
    if (!projectId) return res.status(400).json({ error: "missing_project_scope" });

    const status = (req.query.status ? String(req.query.status) : null);
    const params: any[] = [projectId];
    let where = "project_id = $1";
    if (status && ["new", "keep", "trash"].includes(status)) {
      params.push(status);
      where += ` AND status = $${params.length}`;
    }

    const q = `
      SELECT id, project_id, user_id, title, url, status, tags, created_at, updated_at
      FROM captures
      WHERE ${where}
      ORDER BY created_at DESC
      LIMIT 200
    `;
    const { rows } = await pool.query(q, params);
    return res.json(rows ?? []);
  } catch (e) {
    next(e);
  }
});

// PATCH /api/captures/:id/status  { status: 'new'|'keep'|'trash' }
router.patch("/captures/:id/status", async (req, res, next) => {
  try {
    if (!req.user) return res.status(401).json({ error: "unauthorized" });
    const projectId = (req as any).projectId as string | undefined;
    if (!projectId) return res.status(400).json({ error: "missing_project_scope" });

    const id = req.params.id;
    const status = String(req.body?.status ?? "");
    if (!["new", "keep", "trash"].includes(status)) {
      return res.status(400).json({ error: "invalid_status" });
    }

    const q = `
      UPDATE captures
      SET status = $1, updated_at = now()
      WHERE id = $2 AND project_id = $3
      RETURNING id, project_id, user_id, title, url, status, tags, created_at, updated_at
    `;
    const { rows } = await pool.query(q, [status, id, projectId]);
    if (!rows[0]) return res.status(404).json({ error: "not_found" });
    return res.json(rows[0]);
  } catch (e) {
    next(e);
  }
});

export default router;

Mount the route: open server/routes/index.ts and add:

import capturesBasic from "./captures-basic";

export function registerRoutes(app: any) {
  // …existing mounts…
  app.use("/api", capturesBasic);
  // …keep other routes…
}

This ensures a stable, minimal path for the Inbox regardless of legacy/advanced routes.

⸻

30.2 Client — Canonical captures service

Create/replace client/src/ui-v2/services/captures.ts:

// client/src/ui-v2/services/captures.ts
import { api } from "../lib/api";

export type Capture = {
  id: string;
  project_id: string;
  user_id: string;
  title: string | null;
  url: string | null;
  status: "new" | "keep" | "trash";
  tags?: string[];
  created_at: string;
  updated_at: string;
};

export async function listCaptures(opts?: { status?: "new" | "keep" | "trash" }) {
  const sp = new URLSearchParams();
  if (opts?.status) sp.set("status", opts.status);
  const path = sp.toString() ? `/captures?${sp}` : "/captures";
  return api.get<Capture[]>(path);
}

export async function updateCaptureStatus(id: string, status: "new" | "keep" | "trash") {
  return api.patch<Capture>(`/captures/${id}/status`, { status });
}


⸻

30.3 Client — Fix the Inbox page to use the canonical service

Open client/src/ui-v2/pages/CapturesInboxPage.tsx and update:
	1.	Imports (replace any prior imports for captures with this):

import { listCaptures, updateCaptureStatus, type Capture } from "../services/captures";
import { useProjectContext } from "../context/ProjectContext";
import { useEffect, useState, useCallback } from "react";

	2.	State + load logic (replace the component body with a safe, minimal version that respects project scope and never assumes array shapes):

export default function CapturesInboxPage() {
  const { currentProjectId } = useProjectContext();
  const [captures, setCaptures] = useState<Capture[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [statusFilter, setStatusFilter] = useState<"new" | "keep" | "trash" | "all">("new");
  const [error, setError] = useState<string | null>(null);

  const load = useCallback(async () => {
    if (!currentProjectId) {
      setCaptures([]);
      return;
    }
    setIsLoading(true);
    setError(null);
    try {
      const list = await listCaptures(statusFilter === "all" ? undefined : { status: statusFilter });
      setCaptures(Array.isArray(list) ? list : []);
    } catch (e: any) {
      setError(e?.message || "Failed to load captures");
      setCaptures([]);
    } finally {
      setIsLoading(false);
    }
  }, [currentProjectId, statusFilter]);

  useEffect(() => { void load(); }, [load]);

  const onUpdateStatus = async (id: string, status: "new" | "keep" | "trash") => {
    try {
      await updateCaptureStatus(id, status);
      // optimistic: update local list
      setCaptures(prev => prev.map(c => (c.id === id ? { ...c, status } : c)));
    } catch (e) {
      console.error(e);
    }
  };

  return (
    <div className="p-4">
      <div className="mb-3 flex items-center gap-2">
        <select
          value={statusFilter}
          onChange={(e) => setStatusFilter(e.target.value as any)}
          className="border rounded px-2 py-1"
        >
          <option value="new">New</option>
          <option value="keep">Keep</option>
          <option value="trash">Trash</option>
          <option value="all">All</option>
        </select>
        <button className="border rounded px-2 py-1" onClick={() => load()} disabled={isLoading}>
          Refresh
        </button>
      </div>

      {isLoading && <div>Loading…</div>}
      {error && <div className="text-red-600">{error}</div>}

      {!isLoading && captures.length === 0 && <div>No captures.</div>}

      <ul className="space-y-2">
        {captures.map(c => (
          <li key={c.id} className="border rounded p-3 flex items-center justify-between">
            <div className="min-w-0">
              <div className="font-medium truncate">{c.title || c.url || "Untitled"}</div>
              {c.url && (
                <a className="text-sm underline break-all" href={c.url} target="_blank" rel="noreferrer">
                  {c.url}
                </a>
              )}
              <div className="text-xs text-gray-500 mt-1">
                {new Date(c.created_at).toLocaleString()} • status: {c.status}
              </div>
            </div>
            <div className="flex items-center gap-2">
              <button className="px-2 py-1 border rounded" onClick={() => onUpdateStatus(c.id, "new")}>
                Mark New
              </button>
              <button className="px-2 py-1 border rounded" onClick={() => onUpdateStatus(c.id, "keep")}>
                Keep
              </button>
              <button className="px-2 py-1 border rounded" onClick={() => onUpdateStatus(c.id, "trash")}>
                Trash
              </button>
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
}

This fixes the earlier signature mismatch (updateStatus expecting two args) and the .find on non-array issue.

⸻

30.4 Typecheck & run

npm run typecheck || true
npm run dev


⸻

30.5 Validation

Browser (port 3000):
	•	Navigate to Inbox/Captures page.
	•	You should see “New” captures (or empty state).
	•	Change filter to “All”, “Keep”, “Trash” and back—no crashes.
	•	Click “Keep” or “Trash” on a row—status should update instantly and persist on refresh.

Shell sanity:

# Proxy via Vite
curl -sSf http://localhost:5175/api/captures | head -c 200; echo
# Direct API
curl -sSf http://localhost:5001/captures | head -c 200; echo

Pass criteria
	•	No console errors from ProjectSwitcher or Inbox.
	•	Status updates succeed without reloading the whole page.
	•	All calls carry X-Project-ID (verify in server logs) and return project-scoped results only.

⸻

Outcome:
The Inbox is now stable and project-scoped with clean client services and minimal, reliable server endpoints. This sets the stage for Step 31 (Truth Lab: URL/Text analysis submission + job status polling) without UI crashes or ambiguous state.