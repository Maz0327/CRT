You are my repo ops assistant. Continue from STEP 9. 
After EACH step: STOP and print status, key output, and “Reply ‘continue’ to proceed” OR a **HUMAN STEP**.

Do not reveal secret values. Do not run forbidden commands. Never skip steps.

────────────────────────────────────────────────────────
STEP 9 — Create a single API client used by UI-v2
────────────────────────────────────────────────────────
Goal: Fix “api.get/patch does not exist” errors by providing a unified wrapper.

9.1) Create/overwrite client/src/ui-v2/services/api.ts with:

---BEGIN---
export type Json = Record<string, any> | any[] | string | number | boolean | null;

const API_BASE =
  (import.meta as any)?.env?.VITE_API_BASE ||
  (import.meta as any)?.env?.VITE_API_URL ||
  "/api";

async function request<T>(path: string, init: RequestInit = {}): Promise<T> {
  const url = path.startsWith("http") ? path : `${API_BASE}${path}`;
  const headers = new Headers(init.headers || {});
  if (!headers.has("content-type") && init.body && !(init.body instanceof FormData)) {
    headers.set("content-type", "application/json");
  }
  const res = await fetch(url, { ...init, headers, credentials: "include" });
  if (!res.ok) {
    let detail: any;
    try { detail = await res.json(); } catch { detail = await res.text(); }
    throw new Error(typeof detail === "string" ? detail : detail?.error || `HTTP ${res.status}`);
  }
  const ct = res.headers.get("content-type") || "";
  if (ct.includes("application/json")) return res.json() as Promise<T>;
  return (await res.text()) as unknown as T;
}

export const api = {
  request,
  get<T>(path: string, init: RequestInit = {}) {
    return request<T>(path, { ...init, method: "GET" });
  },
  post<T>(path: string, body?: Json, init: RequestInit = {}) {
    return request<T>(path, { ...init, method: "POST", body: body instanceof FormData ? body : JSON.stringify(body ?? {}) });
  },
  patch<T>(path: string, body?: Json, init: RequestInit = {}) {
    return request<T>(path, { ...init, method: "PATCH", body: body instanceof FormData ? body : JSON.stringify(body ?? {}) });
  },
  put<T>(path: string, body?: Json, init: RequestInit = {}) {
    return request<T>(path, { ...init, method: "PUT", body: body instanceof FormData ? body : JSON.stringify(body ?? {}) });
  },
  delete<T>(path: string, init: RequestInit = {}) {
    return request<T>(path, { ...init, method: "DELETE" });
  }
};

export default api;
---END---

9.2) Grep for existing imports of api to ensure it points to this file:
- `grep -RIn "from './services/api'\\|from '../services/api'\\|from '../../services/api'" client/src || true`

9.3) If other files import a different api (e.g., client/src/lib/api.ts), DO NOT delete them yet—just report their paths.

STOP and wait for “continue”.

────────────────────────────────────────────────────────
STEP 10 — Quick type shims to unblock compile (server)
────────────────────────────────────────────────────────
Goal: silence common TS “missing types” that don’t affect runtime.

10.1) Create server/types/shims.d.ts with:

---BEGIN---
/// <reference types="node" />
declare module 'node-cron';
declare module 'pdf-parse';
declare module '@mozilla/readability';
declare module 'jsdom';
declare module '@google-cloud/vision';
---END---

10.2) Ensure server/tsconfig.json includes `"typeRoots": ["./types", "./node_modules/@types"]` (add if missing). Show the “compilerOptions” block after edit.

STOP and wait for “continue”.

────────────────────────────────────────────────────────
STEP 11 — UI-v2 type relaxations (local, minimal)
────────────────────────────────────────────────────────
Goal: resolve common prop/type mismatches without changing UX.

11.1) Edit client/src/ui-v2/types.ts:
- Change `weight?: string;` to `weight?: string | number;`
- If Slide/Block shapes exist and UI uses `w`/`h`, add optional fields:  
  `w?: number; h?: number;`

11.2) Popover types:
- Locate components that declare `PopoverMenuProps` / `PopoverMenuItemProps` (search in client/src/ui-v2/**).
- Extend types to allow extra optional props used by callers:
  - `align?: string;`
  - For menu items: `destructive?: boolean;`
- Do NOT change behavior—just allow the props.

11.3) Show git-style diffs or the lines changed for each file edited in step 11.

STOP and wait for “continue”.

────────────────────────────────────────────────────────
STEP 12 — Fix the CapturesInboxPage updateStatus signature
────────────────────────────────────────────────────────
Goal: calls like `updateStatus({ id, status: 'new' })` should compile.

12.1) Open client/src/ui-v2/pages/CapturesInboxPage.tsx.
Find the function:
`const updateStatus = async (captureId: string, status: 'new' | 'keep' | 'trash') => { ... }`

12.2) Replace with an overload that accepts either form:

---BEGIN---
type CaptureStatus = 'new' | 'keep' | 'trash';
async function updateStatus(captureId: string, status: CaptureStatus): Promise<void>;
async function updateStatus(args: { id: string; status: CaptureStatus }): Promise<void>;
async function updateStatus(a: string | { id: string; status: CaptureStatus }, b?: CaptureStatus) {
  const id = typeof a === 'string' ? a : a.id;
  const st = typeof a === 'string' ? (b as CaptureStatus) : a.status;
  // existing body, but use (id, st)
  // example:
  // await api.patch(`/captures/${id}`, { status: st });
}
---END---

12.3) Keep the original implementation body logic; only adjust parameter handling.
12.4) Show the updated function block (only).

STOP and wait for “continue”.

────────────────────────────────────────────────────────
STEP 13 — Moments & Projects services to use the new api
────────────────────────────────────────────────────────
Goal: fix “api.get/patch not found” in services.

13.1) Edit client/src/ui-v2/services/moments.ts:
- Ensure it imports `api` from `./api`.
- Replace any `api.request(...)` with `api.get(...)` / `api.patch(...)` as appropriate:
  - `listMoments`: `api.get<Moment[]>(\`/moments?\${searchParams}\`)`
  - `getMoment`: `api.get<Moment>(\`/moments/\${id}\`)`
  - `updateMoment`: `api.patch<Moment>(\`/moments/\${id}\`, data)`

13.2) Edit client/src/ui-v2/services/projects.ts:
- Ensure it imports `api` from `./api`.
- Return arrays robustly:
  `return api.get<any>('/projects').then((res:any)=> res?.rows ?? res?.data ?? [])`

13.3) Show diffs for both files.

STOP and wait for “continue”.

────────────────────────────────────────────────────────
STEP 14 — Re-run typecheck and report deltas
────────────────────────────────────────────────────────
14.1) `npm run typecheck || true`
14.2) Count remaining errors:
- `node -e "const s=require('fs').readFileSync('artifacts/type-err.txt','utf8'); const m=[...s.matchAll(/error TS\\d+/g)]; console.log('Errors:',m.length)"` 
(If artifacts/type-err.txt doesn’t exist, just paste the tsc summary.)
14.3) Paste the first 40 error lines so we can prioritize.

STOP and wait for “continue”.

────────────────────────────────────────────────────────
STEP 15 — Sanity run and route smoke
────────────────────────────────────────────────────────
15.1) Kill background servers:
- `pkill -f "vite|tsx server/index.ts" 2>/dev/null || true`

15.2) Start normal dev:
- `npm run dev`

15.3) In parallel, curl a few API routes we expect to exist (adjust if not found in inventory):
- `curl -sS http://localhost:5001/healthz || true`
- `curl -sS http://localhost:5001/api/healthz || true`
- `curl -sS http://localhost:5001/api/projects || true`

If any 404/500 appear and the route should exist, STOP and print a short diagnosis. If a route is simply not implemented, print **HUMAN STEP: confirm desired API shape for <route>**, then STOP.

If all good, STOP and say: “Dev healthy. Reply ‘continue’ to proceed with the next batch (feeds/projects hooks and UI fixes).”