Here’s what (if anything) you need to do before the agent runs Step 29. After that, you’ll get a separate block for the Replit agent.

⸻

Human steps (quick)
	1.	Be logged in to the UI (port 3000) as a user (the seeded test account is fine):
	•	Email: test@example.com
	•	Password: test123

No config or secrets changes are needed for this step.

⸻

Replit Agent — Step 29 (Project bootstrap + ProjectSwitcher UX & persistence)

Objective:
Guarantee every authenticated user can see or create at least one project, safely load projects in the UI, persist the current selection, and ensure the X-Project-ID header is set for all API calls (using step-28’s setScopedProjectId).

⸻

29.1 Server: DB helpers for projects

Create: server/lib/db/projects.ts (back up any existing file, then replace with this)

// server/lib/db/projects.ts
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === "production" ? { rejectUnauthorized: false } : false,
});

export type Project = {
  id: string;
  name: string;
  owner_id: string;
  created_at: string | Date;
  updated_at: string | Date;
};

// NOTE: adjust table/column names if your schema differs.
// Assumes a projects table with (id uuid pk, name text, owner_id uuid, created_at, updated_at)
// and a membership/ACL model where owner_id implies access.

export async function listProjectsForUser(userId: string): Promise<Project[]> {
  const q = `
    select id, name, owner_id, created_at, updated_at
    from projects
    where owner_id = $1
    order by updated_at desc nulls last, created_at desc
  `;
  const { rows } = await pool.query(q, [userId]);
  return rows as Project[];
}

export async function userHasAccessToProject(userId: string, projectId: string): Promise<boolean> {
  const q = `
    select 1
    from projects
    where id = $1 and owner_id = $2
    limit 1
  `;
  const { rowCount } = await pool.query(q, [projectId, userId]);
  return rowCount === 1;
}

export async function createProject(userId: string, name: string): Promise<Project> {
  const q = `
    insert into projects (name, owner_id)
    values ($1, $2)
    returning id, name, owner_id, created_at, updated_at
  `;
  const { rows } = await pool.query(q, [name, userId]);
  return rows[0] as Project;
}

export async function firstOwnedOrRecentProjectId(userId: string): Promise<string | null> {
  const q = `
    select id
    from projects
    where owner_id = $1
    order by updated_at desc nulls last, created_at desc
    limit 1
  `;
  const { rows } = await pool.query(q, [userId]);
  return rows[0]?.id ?? null;
}

These functions satisfy the references added in Step 28 (firstOwnedOrRecentProjectId) and give us a clean surface for routes.

⸻

29.2 Server: Projects routes

Create/Replace: server/routes/projects.ts

// server/routes/projects.ts
import { Router } from "express";
import {
  listProjectsForUser,
  createProject,
  userHasAccessToProject,
} from "../lib/db/projects";

const router = Router();

// GET /api/projects -> Project[]
router.get("/projects", async (req, res, next) => {
  try {
    if (!req.user) return res.status(401).json({ error: "unauthorized" });
    const list = await listProjectsForUser(req.user.id);
    return res.json(Array.isArray(list) ? list : []);
  } catch (e) {
    next(e);
  }
});

// POST /api/projects { name } -> Project
router.post("/projects", async (req, res, next) => {
  try {
    if (!req.user) return res.status(401).json({ error: "unauthorized" });
    const name = String((req.body?.name ?? "")).trim();
    if (!name) return res.status(400).json({ error: "name_required" });
    const proj = await createProject(req.user.id, name);
    return res.status(201).json(proj);
  } catch (e) {
    next(e);
  }
});

// GET /api/projects/:id/access -> { ok: boolean }
router.get("/projects/:id/access", async (req, res, next) => {
  try {
    if (!req.user) return res.status(401).json({ error: "unauthorized" });
    const ok = await userHasAccessToProject(req.user.id, req.params.id);
    return res.json({ ok });
  } catch (e) {
    next(e);
  }
});

export default router;

Mount route: open server/routes/index.ts and add:

import projects from "./projects";

Inside registerRoutes(app) add (after /api/me mount from step 28):

app.use("/api", projects);


⸻

29.3 Server: Project-scope middleware hook verification

Open server/middleware/project-scope.ts (from Step 28) and ensure it imports these helpers rather than a generic db:

import { userHasAccessToProject, firstOwnedOrRecentProjectId } from "../lib/db/projects";
// ...then use those functions where referenced previously


⸻

29.4 Client: Project context provider (safe array + persistence)

Create/Replace: client/src/ui-v2/context/ProjectContext.tsx

import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from "react";
import { api } from "../lib/api";

type Project = { id: string; name: string };

type Ctx = {
  projects: Project[];
  currentProjectId: string | null;
  setCurrentProjectId: (id: string | null) => void;
  refresh: () => Promise<void>;
  create: (name: string) => Promise<void>;
  isLoading: boolean;
  error: string | null;
};

const ProjectContext = createContext<Ctx | null>(null);
const KEY = "cr.currentProjectId";

export const ProjectProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [projects, setProjects] = useState<Project[]>([]);
  const [currentProjectId, setCurrentProjectIdState] = useState<string | null>(
    () => window.localStorage.getItem(KEY) || null
  );
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const setCurrentProjectId = useCallback((id: string | null) => {
    setCurrentProjectIdState(id);
    if (id) window.localStorage.setItem(KEY, id);
    else window.localStorage.removeItem(KEY);
  }, []);

  const refresh = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const list = await api.get<Project[]>("/projects");
      const safe = Array.isArray(list) ? list : [];
      setProjects(safe);

      if (safe.length === 0) {
        // leave currentProjectId as-is (null)
      } else if (!currentProjectId || !safe.find(p => p.id === currentProjectId)) {
        setCurrentProjectId(safe[0].id);
      }
    } catch (e: any) {
      setError(e?.message || "Failed to load projects");
    } finally {
      setIsLoading(false);
    }
  }, [currentProjectId, setCurrentProjectId]);

  const create = useCallback(async (name: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const proj = await api.post<Project>("/projects", { name });
      setProjects(prev => [proj, ...prev]);
      setCurrentProjectId(proj.id);
    } catch (e: any) {
      setError(e?.message || "Failed to create project");
    } finally {
      setIsLoading(false);
    }
  }, [setCurrentProjectId]);

  useEffect(() => {
    void refresh();
  }, []); // initial load

  const value = useMemo<Ctx>(() => ({
    projects,
    currentProjectId,
    setCurrentProjectId,
    refresh,
    create,
    isLoading,
    error,
  }), [projects, currentProjectId, setCurrentProjectId, refresh, create, isLoading, error]);

  return <ProjectContext.Provider value={value}>{children}</ProjectContext.Provider>;
};

export function useProjectContext(): Ctx {
  const ctx = useContext(ProjectContext);
  if (!ctx) throw new Error("useProjectContext must be used within ProjectProvider");
  return ctx;
}

Wire provider: open client/src/ui-v2/app/providers.tsx
	•	Ensure we wrap the app with ProjectProvider (outside AuthProvider is fine; either order works if Auth provides req.user).
	•	Ensure we import and call setScopedProjectId (already added in Step 28) whenever currentProjectId changes:

import { ProjectProvider, useProjectContext } from "../context/ProjectContext";
import { setScopedProjectId } from "../lib/api";
import { useEffect } from "react";

// ... inside Providers component composition, wrap children with <ProjectProvider>...</ProjectProvider>

// wherever you have access to currentProjectId (inside a small bridge component is fine):
function ProjectScopeBridge() {
  const { currentProjectId } = useProjectContext();
  useEffect(() => { setScopedProjectId(currentProjectId || undefined); }, [currentProjectId]);
  return null;
}

// Render <ProjectScopeBridge /> once within providers tree.


⸻

29.5 Client: ProjectSwitcher hardening

Open client/src/ui-v2/components/layout/ProjectSwitcher.tsx and make it resilient:
	•	Ensure projects are treated as an array:

const { projects, currentProjectId, setCurrentProjectId, create, isLoading } = useProjectContext();
const safeProjects = Array.isArray(projects) ? projects : [];
const current = safeProjects.find(p => p.id === currentProjectId) || null;

	•	If there are no projects, render a minimal “Create your first project” CTA:

if (!isLoading && safeProjects.length === 0) {
  return (
    <button
      className="btn btn-primary"
      onClick={() => create("My First Project")}
    >
      Create Project
    </button>
  );
}

	•	On selection, call setCurrentProjectId(id); do not call .find on a possibly non-array.

⸻

29.6 Typecheck & run

npm run typecheck || true
npm run dev


⸻

29.7 Success checks

Browser (port 3000):
	•	Header ProjectSwitcher shows a project list or a Create Project button.
	•	Creating a project populates the list and selects it; selection persists after refresh.
	•	Navigating around the app keeps the same current project context.

Server logs:
	•	No projects.find is not a function errors.
	•	No 401/403s when loading pages while logged in.

Shell (optional sanity):

# With browser session established, these should succeed through the proxy:
curl -sSf http://localhost:5175/api/projects | head -c 200; echo
# And direct API:
curl -sSf http://localhost:5001/api/projects | head -c 200; echo

Pass criteria
	•	Authenticated users always see a valid project context (either existing or newly created).
	•	UI never crashes when projects are empty.
	•	X-Project-ID is set automatically (verified by server-side logs on any /api/* call).