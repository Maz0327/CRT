Awesome—now we wire Truth Lab end-to-end so strategists can analyze single texts and bundled screenshots/links, persist results as “Receipts,” and fetch them cleanly.

Step 37 — Truth Lab pipeline (text + bundles + receipts)

Human steps (do these first)
	1.	Confirm these secrets exist in Replit → Secrets (exact names):
	•	OPENAI_API_KEY
	•	SUPABASE_URL
	•	SUPABASE_SERVICE_KEY (server-side admin)
	•	SESSION_SECRET
	•	ALLOWED_ORIGINS (must include your Preview host on port 3000)
	2.	(If you want screenshot OCR and URL extraction in this step) Ensure Google creds are already working (we used them earlier):
	•	GOOGLE_APPLICATION_CREDENTIALS_JSON (or a path via GOOGLE_APPLICATION_CREDENTIALS written at boot)

When you’re done, tell the agent to run the block below.

⸻

Replit Agent — execute exactly in order

37.1 Create a minimal OpenAI server wrapper

File: server/services/ai/openai.ts

import OpenAI from "openai";

if (!process.env.OPENAI_API_KEY) {
  throw new Error("[openai] Missing OPENAI_API_KEY");
}

export const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

export async function chatJSON({
  model,
  system,
  user,
  maxTokens = 1500,
}: {
  model: string;
  system: string;
  user: string;
  maxTokens?: number;
}) {
  const res = await openai.chat.completions.create({
    model,
    temperature: 0.2,
    response_format: { type: "json_object" },
    messages: [
      { role: "system", content: system },
      { role: "user", content: user },
    ],
    max_tokens: maxTokens,
  });
  const text = res.choices?.[0]?.message?.content ?? "{}";
  return JSON.parse(text);
}

37.2 Add Truth Lab prompts (Steve Jobs narrative + strict JSON)

File: server/services/truth/prompt.ts

export function truthSystemPrompt() {
  return [
    "You are a senior cultural strategist.",
    "Transform messy inputs (posts, screenshots, threads) into a clean, evidence-backed Truth Chain.",
    "No fluff. No generic advice. Every claim must be tied to receipts.",
    "Use direct quotes sparingly and always include source+timestamp when available.",
    "Return strictly valid JSON following the provided schema.",
  ].join(" ");
}

export function truthUserPrompt({
  title,
  mergedText,
  sourceHints,
}: {
  title?: string;
  mergedText: string;
  sourceHints?: string[];
}) {
  const schema = {
    title: "max 80-char headline",
    summary: "2-line summary of what & why",
    truth_chain: {
      fact: "",
      observation: "",
      insight: "",
      human_truth: "",
      cultural_moment: "",
    },
    cohorts: ["array of succinct audience cohort names"],
    strategic_moves: ["specific actions"],
    evidence: [
      { quote: "", url: "", timestamp: "", source: "" }
    ],
    confidence: 0.0,
    why_this_surfaced: "one clear sentence tied to prior behavior or project",
  };

  return [
    title ? `Title: ${title}` : "",
    "Inputs below (may contain multiple posts/screenshots/links stitched together with separators):",
    "----- BEGIN INPUT -----",
    mergedText,
    "----- END INPUT -----",
    sourceHints && sourceHints.length ? `Sources: ${sourceHints.join(", ")}` : "",
    "Return JSON only with the exact keys:",
    JSON.stringify(schema, null, 2),
  ].filter(Boolean).join("\n\n");
}

37.3 Minimal extraction helpers (URL text + OCR for screenshots)

File: server/services/truth/extract.ts

import fetch from "node-fetch";

export async function extractFromUrl(url: string): Promise<string> {
  // MVP: fetch raw HTML and fallback to text content
  // (You can upgrade to Readability later.)
  try {
    const res = await fetch(url, { timeout: 10000 });
    const html = await res.text();
    // naive strip
    const text = html.replace(/<script[\s\S]*?<\/script>/gi, " ")
                     .replace(/<style[\s\S]*?<\/style>/gi, " ")
                     .replace(/<[^>]+>/g, " ")
                     .replace(/\s+/g, " ")
                     .trim();
    return text.slice(0, 40000); // cap
  } catch {
    return "";
  }
}

// OCR hook (wire to Google Vision later); return "" when not available
export async function ocrImagePlaceholder(_publicUrl: string): Promise<string> {
  return ""; // keep placeholder in this step; we’ll upgrade in a later step
}

37.4 Truth pipeline (single text or bundled)

File: server/services/truth/pipeline.ts

import { chatJSON } from "../ai/openai";
import { truthSystemPrompt, truthUserPrompt } from "./prompt";
import { extractFromUrl, ocrImagePlaceholder } from "./extract";
// If you have DB helpers/services already, import them here.
import { v4 as uuid } from "uuid";

const MODEL_STRICT = process.env.TRUTH_LAB_MODEL || "gpt-5-thinking"; // changeable by env

export type BundleInput = {
  title?: string;
  text?: string;                // direct user-provided text
  urls?: string[];              // web pages to extract text from
  imageUrls?: string[];         // screenshots (OCR later)
  captureSnippets?: string[];   // already-stored text from captures
};

export async function analyzeTruthBundle({
  userId,
  projectId,
  input,
}: {
  userId: string;
  projectId?: string | null;
  input: BundleInput;
}) {
  // 1) Gather text
  const parts: string[] = [];
  if (input.text) parts.push(input.text);

  if (input.urls?.length) {
    for (const u of input.urls) {
      const t = await extractFromUrl(u);
      if (t) parts.push(`[URL: ${u}]\n${t}`);
    }
  }
  if (input.imageUrls?.length) {
    for (const img of input.imageUrls) {
      const t = await ocrImagePlaceholder(img);
      if (t) parts.push(`[IMAGE: ${img} OCR]\n${t}`);
    }
  }
  if (input.captureSnippets?.length) {
    for (const s of input.captureSnippets) {
      parts.push(`[CAPTURE]\n${s}`);
    }
  }
  const merged = parts.join("\n\n---\n\n").slice(0, 80000);
  if (!merged) {
    return { error: "No analyzable text" };
  }

  // 2) Call model
  const system = truthSystemPrompt();
  const user = truthUserPrompt({
    title: input.title,
    mergedText: merged,
    sourceHints: input.urls,
  });

  const result = await chatJSON({
    model: MODEL_STRICT,
    system,
    user,
    maxTokens: 2000,
  });

  // 3) Persist (MVP: naive save; replace with your services/DAO)
  const truthCheckId = uuid();
  // TODO: replace with actual DB saves using your services and schema:
  // - save truth_checks row (id, user_id, project_id, payload, result)
  // - save evidence array to truth_evidence
  // - link receipts to captures when applicable

  return { truthCheckId, result };
}

37.5 HTTP routes for Truth Lab

File: server/routes/truth.ts

import type { Express, Request, Response } from "express";
import { requireAuth } from "../middleware/auth";
import { analyzeTruthBundle } from "../services/truth/pipeline";

export default function mountTruthRoutes(app: Express) {
  app.get("/api/truth/health", (_req: Request, res: Response) =>
    res.json({ ok: true })
  );

  // Simple text analysis (single input)
  app.post("/api/truth/analyze-text", requireAuth, async (req: Request, res: Response) => {
    const userId = req.user!.id;
    const projectId = (req.headers["x-project-id"] as string) || null;
    const { text, title } = req.body || {};
    const out = await analyzeTruthBundle({
      userId,
      projectId,
      input: { text, title },
    });
    if ((out as any).error) return res.status(400).json(out);
    return res.json(out);
  });

  // Bundle analysis (URLs, screenshots, capture snippets)
  app.post("/api/truth/analyze-bundle", requireAuth, async (req: Request, res: Response) => {
    const userId = req.user!.id;
    const projectId = (req.headers["x-project-id"] as string) || null;
    const { title, text, urls, imageUrls, captureSnippets } = req.body || {};
    const out = await analyzeTruthBundle({
      userId,
      projectId,
      input: { title, text, urls, imageUrls, captureSnippets },
    });
    if ((out as any).error) return res.status(400).json(out);
    return res.json(out);
  });

  // TODO (later step): GET /api/truth/check/:id to fetch saved result from DB
}

Wire it in server/index.ts (after auth/projectScope and before 404 handler)

import mountTruthRoutes from "./routes/truth";
// ...
mountTruthRoutes(app);

37.6 Client service: match UI-V2 expectations

File: client/src/ui-v2/services/truth.ts

type ID = string;

export async function createTruthCheck(payload: {
  text?: string;
  title?: string;
  urls?: string[];
  imageUrls?: string[];
  captureSnippets?: string[];
}) {
  // decide endpoint: single text vs bundle
  const isBundle = (payload.urls?.length || payload.imageUrls?.length || payload.captureSnippets?.length);
  const path = isBundle ? "/api/truth/analyze-bundle" : "/api/truth/analyze-text";
  const res = await fetch(path, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      // X-Project-ID is set globally in your fetch wrapper or add here if needed
    },
    body: JSON.stringify(payload),
  });
  if (!res.ok) throw new Error(`Truth analysis failed: ${res.status}`);
  return res.json() as Promise<{ truthCheckId: ID; result: any }>;
}

export function getTruthCheck(_id: ID) {
  // implement later when server exposes /api/truth/check/:id
  throw new Error("getTruthCheck not yet implemented in Step 37");
}

Note: We export createTruthCheck because your UI referenced it earlier. This keeps the UI compiling and able to submit analysis.

37.7 Smoke tests (no UI)

# 1) Health
curl -sS http://localhost:5001/api/truth/health | jq .

# 2) Expect 401 without token
curl -sS -X POST http://localhost:5001/api/truth/analyze-text -H "Content-Type: application/json" -d '{"text":"Sample claim"}' | jq .

# 3) With a real user token (paste one)
TOKEN="PASTE_USER_ACCESS_TOKEN"
curl -sS -X POST http://localhost:5001/api/truth/analyze-text \
  -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
  -H "X-Project-ID: demo" \
  -d '{"title":"Test", "text":"TikTok creators are shifting to long-form explainers to build trust."}' | jq .

# 4) Bundle (URLs + snippets)
curl -sS -X POST http://localhost:5001/api/truth/analyze-bundle \
  -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" \
  -H "X-Project-ID: demo" \
  -d '{
    "title":"Shift: Long-form explainers",
    "urls":["https://example.com/some-article"],
    "captureSnippets":["Thread of comments praising step-by-step breakdowns on complex topics"]
  }' | jq .

37.8 Commit & tag

git add -A
git commit -m "feat(truth-lab): text & bundle analysis endpoints with receipts-ready schema"
git tag -f step-37-truth-lab
git push && git push --force --tags


⸻

What you get after Step 37
	•	Backend endpoints to analyze single text or bundled screenshots/URLs/snippets.
	•	Strict JSON output aligned to our Truth Chain and “no fluff” Steve Jobs narrative.
	•	Client service createTruthCheck(...) that your UI can call right now.
	•	A path to receipts and persistence (the code clearly marks where to wire real DB saves—coming in the next step).

When this is green, we’ll do Step 38: wire persistence (truth_checks & truth_evidence), add /api/truth/check/:id, and surface results in the UI with proper loading states and receipts.