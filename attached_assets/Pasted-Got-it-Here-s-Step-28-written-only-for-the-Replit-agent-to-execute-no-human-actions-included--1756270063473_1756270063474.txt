Got it. Here’s Step 28 written only for the Replit agent to execute — no human actions included.

⸻

Step 28 — Auth & Project-Scoping E2E Hardening (Agent-only)

28.1 Add /api/me (authenticated identity probe)

Create: server/routes/me.ts

import { Router } from "express";

const router = Router();

// GET /api/me  -> { id, email } or 401
router.get("/me", (req, res) => {
  // req.user is set by our auth middleware
  if (!req.user) return res.status(401).json({ error: "unauthorized" });
  const { id, email } = req.user;
  return res.json({ id, email });
});

export default router;

Wire it up: edit server/routes/index.ts
	•	Import and mount the route before other API groups:

import me from "./me";
// ...
export function registerRoutes(app: import("express").Express) {
  app.use("/api", me);
  // ... rest of existing mounts
}


⸻

28.2 Server project scoping safety net

Open: server/middleware/project-scope.ts
Ensure the middleware:
	1.	Reads X-Project-ID (when present).
	2.	Validates access for the authenticated user.
	3.	Falls back to a safe default project (first owned/active) if header missing.
	4.	Emits 403 {error:"project_access_denied"} if the user lacks access.
	5.	Attaches req.projectId for downstream handlers.

If missing or incomplete, replace the handler with:

import { NextFunction, Request, Response } from "express";
import { db } from "../lib/db"; // adjust to your DB access helper
import { projects } from "../db/schema"; // adjust import to your schema

declare global {
  namespace Express {
    interface Request {
      projectId?: string | null;
    }
  }
}

export async function projectScope(req: Request, res: Response, next: NextFunction) {
  try {
    if (!req.user) {
      // Public endpoints may skip; authenticated endpoints should reject upstream
      req.projectId = null;
      return next();
    }

    const headerId = (req.headers["x-project-id"] as string | undefined)?.trim();
    let resolved: string | null = null;

    if (headerId) {
      // validate user access to headerId
      const hasAccess = await db.hasProjectAccess(req.user.id, headerId); // implement/ensure helper
      if (!hasAccess) return res.status(403).json({ error: "project_access_denied" });
      resolved = headerId;
    } else {
      // pick a default project for this user
      resolved = await db.firstOwnedOrRecentProjectId(req.user.id); // implement/ensure helper
      // If still none, remain null — downstream endpoints should handle gracefully
    }

    req.projectId = resolved;
    return next();
  } catch (err) {
    return next(err);
  }
}

If db.hasProjectAccess / db.firstOwnedOrRecentProjectId don’t exist, implement minimal versions in your DB helper module to query the projects table and the user-project join (if present).

⸻

28.3 Normalize Projects API to always return an array

Open: server/routes/projects.ts (or wherever GET /api/projects is defined)

Ensure handler returns [] (not null, not {rows: …}) on empty:

router.get("/projects", async (req, res, next) => {
  try {
    if (!req.user) return res.status(401).json({ error: "unauthorized" });

    const list = await db.listProjectsForUser(req.user.id); // must return Project[]
    // Always an array
    return res.json(Array.isArray(list) ? list : []);
  } catch (e) {
    next(e);
  }
});


⸻

28.4 Canonical client API helper: scoped header + exports

Open/Replace: client/src/ui-v2/lib/api.ts (this is the single UI v2 API helper)

Replace file contents with:

// Canonical API helper for UI v2

let scopedProjectId: string | undefined;

export function setScopedProjectId(id?: string) {
  scopedProjectId = id?.trim() || undefined;
}

// Keep this export to satisfy existing imports
export const IS_MOCK_MODE = Boolean(import.meta.env.VITE_MOCK_AUTH);

// Base request wrapper (proxied in dev via Vite)
async function request<T>(path: string, init: RequestInit = {}): Promise<T> {
  const headers = new Headers(init.headers || {});
  headers.set("Accept", "application/json");
  if (!headers.has("Content-Type") && init.body) {
    headers.set("Content-Type", "application/json");
  }
  if (scopedProjectId) {
    headers.set("X-Project-ID", scopedProjectId);
  }

  const res = await fetch(`/api${path}`, { ...init, headers, credentials: "include" });
  if (!res.ok) {
    const errText = await res.text().catch(() => "");
    throw new Error(`Request failed ${res.status}: ${errText || res.statusText}`);
  }
  const ct = res.headers.get("content-type") || "";
  if (ct.includes("application/json")) return (await res.json()) as T;
  // fallback — return raw text when not JSON
  return (await res.text()) as unknown as T;
}

export const api = {
  get: <T>(path: string, init?: RequestInit) => request<T>(path, { method: "GET", ...(init || {}) }),
  post: <T>(path: string, body?: unknown, init?: RequestInit) =>
    request<T>(path, { method: "POST", body: body ? JSON.stringify(body) : undefined, ...(init || {}) }),
  patch: <T>(path: string, body?: unknown, init?: RequestInit) =>
    request<T>(path, { method: "PATCH", body: body ? JSON.stringify(body) : undefined, ...(init || {}) }),
  delete: <T>(path: string, init?: RequestInit) => request<T>(path, { method: "DELETE", ...(init || {}) }),
};


⸻

28.5 Wire the scoped project id from the provider

Edit: client/src/ui-v2/app/providers.tsx
	•	Ensure the file imports setScopedProjectId from the helper above.
	•	Inside the component that already has access to the current project id (via context/store), set the scoped id reactively.

Add near the top:

import { setScopedProjectId } from "../lib/api";

Add an effect after you read the current project id from context:

import { useEffect } from "react";
// ...
useEffect(() => {
  // Replace `currentProjectId` with your actual variable
  setScopedProjectId(currentProjectId || undefined);
}, [currentProjectId]);


⸻

28.6 Harden ProjectSwitcher and similar consumers

Edit: client/src/ui-v2/components/layout/ProjectSwitcher.tsx
	•	Treat projects as an array, even when undefined.
	•	Guard any .find / .map usage.

Patch example:

const safeProjects = Array.isArray(projects) ? projects : [];
const current = safeProjects.find(p => p.id === currentProjectId) || null;
// Render fallback UI when empty

Apply the same guard pattern to other components reading projects.

⸻

28.7 Minimal error boundary around the shell

Edit: client/src/ui-v2/components/AppShell.tsx (or the top-level layout)
	•	If not present, add a tiny error boundary to prevent a single bad child from blanking the app.
	•	Use React’s ErrorBoundary pattern or a small custom boundary component and wrap the main outlet.

⸻

28.8 Verify & typecheck

Run:
	•	npm run typecheck
	•	npm run dev

Fix any TypeScript errors introduced by these changes (keep diffs small and localized).

⸻

28.9 Logging sanity
	•	Ensure each /api request logs one concise line including method, path, status code, duration, and (for /api/me) the {id,email} snapshot.
	•	Do not log sensitive data or full payloads.

⸻

Success criteria for Step 28
	•	GET /api/me returns {id,email} for an authenticated session, 401 otherwise.
	•	GET /api/projects returns a JSON array in all cases (empty array if none).
	•	All UI API calls automatically include X-Project-ID when a project is selected.
	•	UI no longer crashes on empty or malformed projects — shows a clear fallback state.
	•	No edits required to vite.config.ts in this step.